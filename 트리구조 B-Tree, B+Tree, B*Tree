# 트리구조 B-Tree, B+Tree, B*Tree

# 이진 트리

비트리는 이진트리에서 발전되었다.

이진 트리는 노드가 한 쪽으로 쏠리게 되면 검색 속도가 Full Table Scan 만큼 비효율적이게 된다.

우선 이진트리에 대해 알아보자.

이진트리는 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료구조이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/22674c4d-8599-4e8f-a24f-0cd260b70f7e/Untitled.png)

각각의 노드가 자식(차수)를 2개 이상 가지지 못함.

2도 7이랑 5 두개, 7도 2랑 6 두개…

이진트리에도 종류가 몇개 있다.

1. 정이진트리=포화이진트리 (Full binary tree)
2. 완전이진트리 (Complete binary tree)
3. **균형이진트리 (Balanced binary tree)**

## 정이진트리와 완전이진트리, 균형이진트리

정이진트리는 포화이진트리라고 한다.

말 그대로 leaf node(단말 노드)가끝까지 정말 꽉 차있는 트리를 의미한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/51dda90b-e92f-485f-96d4-0abbdfc176ab/Untitled.png)

완전이진트리는 마지막 레벨을 제외한 모든 레벨에 순서대로 node가 꽉 채워진 트리를 의미한다.

균형 이진 트리는 leaf node (단말 노드)들의 레벨차이가 최대 1레벨까지만 나는 트리를 의미한다.

**→ 균형이 깨지면 별도의 로직을 통해 다시 균형을 유지한다!**

굳이 균형이진트리까지 필요할까?? 싶은데

현실에서는 균형이진트리를 제일 많이 사용한다.

포화이진트리나 완전이진트리는 굉장히 이상적인 만큼 현실에서는 잘 등장하지 않는다.

hello world 세계에서나 쓰일 수 있음..

반면 균형이진트리는 어지러원 real world 세계에서 트리의 높이를 균형적으로 유지시켜줄 수 있다.

**→ 검색할 때 최악의 시간복잡도에서도 O(logN)의 안정성을 유지한다!!**

그리고 균형이진트리는 AVL 트리, 레드블랙 트리, 우리가 앞으로 배울 B-Tree, B+Tree, B8Tree 등에서 주로 사용된다.

이후 얘기할 내용들은 **균형이진탐색트리**의 일종인 B-Tree 이다.

**“탐색”이 붙어있기 때문에 자동으로 정렬도 이루어진다!**

# B-Tree

비트리라고 부른다.

이진트리와 다르게 하나의 노드에 많은 정보를 가질 수 있다.

하나의 노드에 여러 정보를 담게 되면서 **“차수”**라는 개념이 등장한다.

하나의 노드에 담은 자료의 수가 M개라면 M차 B-Tree 라고 부르게 된다.

→ 자식 노드가 최대 M개임을 의미!

이렇게 **하나의 노드에 여러 자료를 배치하게 되면서 이진트리보다 더 많은 데이터를 더 효율적으로 저장**할 수 있게 됐다.

HDD나 SSD와 같은 외부 기억장치는 블럭단위로 파일을 입출력한다.

이 때 발생하는 입출력의 비용은 파일의 크기와는 상관 없이 동일하다.

입출력에 있어서는 1KB 짜리 블럭에 1byte 짜리 알파멧 하나가 들어가 있어도 1KB가 꽉 차 있는 블럭과 차이가 없다는 것.

이 때 하나의 블럭에 여러 데이터들을 동시에 저장할 수 있다면 블럭을 보다 효율적으로 사용할 수 있다.

그래서 많은 데이터베이스들은 B-Tree 를 애용한다.

또한, B-Tree 는 균형 이진트리의 연속이라고 했다.

당연히 **균형도 알아서 잘 유지**한다.

따라서 **아무리 최악의 경우라도 O(logN)의 검색 성능을 보여준다.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ccb69c83-6bf9-4683-b92e-79895ee3347f/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efa008f4-cccb-49a7-b2c1-bd7ec1b84556/Untitled.png)

가장 상단의 노드를 '**루트 노드(Root Node)**', 중간 노드들을 '**브랜치 노드(Branch Node)**', 가장 아래 노드들을 '**리프 노드(Leaf Node)**'라고 한다. 

이진 트리랑 유사하지만 이진 트리와의 차이점은 **한 노드 당 자식 노드가 2개 이상 가능**하다는 것.

key 값을 이용해 찾고자 하는 데이터를 트리 구조를 이용해 찾는 것이다.

### B-Tree가 빠른 이유

B-tree의 장점 한 가지는 '어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다'인데, 이를 '균일성'이라고 한다.

위의 예시에서 리프노드에 있는 '15'나 '25'을 찾는 시간은 동일할 것이다.

(트리 높이가 다른 경우, 약간의 차이는 있겠지만 ***O(logN)***이라는 시간 복잡도를 구할 수 있다.)

### B-Tree 특징

1. 각 노드의 자료는 **정렬되어 있다.**
    1. B-tree의 핵심은 데이터가 정렬된 상태로 유지되어 있다는 것이다.
2. 자료는 중복되지 않는다.
3. 모든 단말 노드는 같엔 레벨에 있다.
4. 루트 노드는 자신이 단말 노드가 되지 않는 이상 적어도 2개 이상의 자식을 가진다.
5. 루트 노드가 아닌 노드들은 적어도 M/2개의 자식 노드를 가지고 있다. (최대 M개)

**비트리 생성 사이트**

[https://www.cs.usfca.edu/~galles/visualization/BTree.html](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

# B*Tree

B-Tree의 단점 중 하나는 구조를 유지하기 위해서 추가적인 연산이 수행되거나 새로운 노드가 생성된다는 것이다.

이진트리가 균형을 유지하기 위해 했던 것들…

**노드의 추가적인 생성과 추가적인 연산의 최소화를 위해서 B-Tree 에서 몇 가지 규칙이 추가 된 B*Tree가 등장**하게 된다.

B-Tree와 B*Tree의 가장 대표적인 차이점이라면 최소 M/2개의 키값을 가져야 했던 기존 노드의 자식 노드 수 최소 제약 조건이 2M/3개로 늘어났고,

**노드가 가득 차면 분열 대신 이웃한 형제 노드로 재배치**를 하게 된다.

→ 더 이상 배치할 수 없는 시점이 되어서야 분열함.

### B*Tree 특징

1. 각 노드의 자료는 정렬되어 있다.
2. 자료는 중복되지 않는다.
3. 모든 단말 노드는 같은 레벨에 있다.
4. 루트 노드는 자신이 단말 노드가 되지 않는 이상 적어도 2개 이상의 자식 노드를 가진다.
5. 루트 노드가 아닌 노드들은 적어도 2[(M-2)/3]+1개의 자식 노드를 가지고 있다. (최대 M개)

# B+Tree

**B-Tree 는 탐색을 위해서 노드를 찾아서 이동해야한다는 단점**이 있다.

이러한 **단점을 해소하고자 B+Tree 는 같은 레벨의 모든 키값들이 정렬되어 있고, 같은 레벨의 Sibiling node 는 연결리스트 형태**로 이어져 있다.

같은 레벨의 Sibiling node는 모두 연결되어 있어서 키값이 중복되지 않는다.

만약 **특정 값을 찾아야 하는 상황이 된다면 단말 노드에 모든 자료들이 존재하고, 그 자료들이 연결리스트로 연결되어 있으므로 탐색에 있어 매우매우 유리**하다!

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27011622-847e-4f8b-92af-0774f7672d51/Untitled.png)

B+tree는 B-tree의 확장개념으로, **B-tree의 경우, internal 또는 branch 노드에 key와 data를 담을 수 있다.** 

**하지만, B+tree의 경우브랜치 노드에 key만 담아두고, data는 담지 않는다.** 

**오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결되어 있다.**

단말 노드가 아닌 자료는 인덱스 노드라고 부르고, 단말 노드는 데이터 노드라고 부른다.

인덱스 노드(단말 노드 x)의 value 값에는 다음 노드를 가리킬 수 잇는 포인터 주소가 존재한다.

데이터 노드(단말 노드 o)의 value 값에 데이터가 존재한다.

따라서 키값은 중복될 수 있고(인덱스 노드 == 단말노드 x 와 데이터 노드 == 단말 노드 o 에서 동시에 등장 가능!), 데이터 검색을 위해서는 반드시 단말 노드까지 내려가야 한다는 특징이 있다.

오늘날 DB에서 가장 중요한 것은 **검색속도** 이기 때문에 대부분의 DB시스템은 B+Tree 구조를 채택하고 있다. 

### B+Tree 장점

1. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 
    
    하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.
    
    (cache hit를 높일 수 있음)
    

1. 풀 스캔 시, B+tree는 **리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면** 되기 때문에 B-tree에 비해 빠르다. 
    
    B-tree의 경우에는 모든 노드를 확인해야 한다.
    

### B+Tree 특징

1. 데이터 노드(단말 노드)의 자료는 정렬되어 있다.
2. 데이터 노드(단말 노드)는 데이터가 중복되지 않는다.
3. 모든 단말 노드는 같은 레벨에 있다.
4. 단말 노드가 아닌 노드의 키값의 수는 그 노드의 서브트리수보다 하나가 적다.
5. 모든 단말 노드는 연결리스트로 연결되어 있다.

***이진트리 < 비-트리 < 비+트리***

# ref

---

[https://ssocoit.tistory.com/217](https://ssocoit.tistory.com/217)

[https://zorba91.tistory.com/293](https://zorba91.tistory.com/293)
