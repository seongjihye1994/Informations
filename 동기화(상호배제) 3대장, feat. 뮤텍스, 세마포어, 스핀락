# 동기화(상호배제) 3대장, feat. 뮤텍스, 세마포어, 스핀락

# 사전 지식

### 🚀 ***race condition (경쟁 조건)***

여러 프로세스/스레드가 동시에 같은 데이터를 조작(manipulation) 할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황을 의미

**⭐ 동시성 이슈**

### ***🚀 동기화  (synchronization)***

여러 프로세스/스레드를 동시에 실행해도 race condition을 발생시키지 않고 공유 데이터의 일관성을 유지하는 것을 의미

**⭐ 레이스 컨디션에 의한 공유 데이터의 결과 변경을 차단**

### ***🚀 critical section (임계 영역)***

공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역을 의미

**⭐ 쓰레드간 동기화를 실행해 크리티컬 섹션에 순서대로 진입**

### ***🚀* mutual exclusion**

한 번에 하나의 프로세스/스레드만 실행하는 것을 의미

**⭐ 쓰레드간 동기화를 실행해 크리티컬 섹션에 순서대로 진입하여 실행됨**

### ***🚀 Dead Lock (교착상태)***

두가지 이상의 작업이 상대방의 작업이 끝날 때 까지 자원을 얻기 위해 하염없이 기다리는 현상

나랑 친구가 필기를 하려고 한다.

나는 연필을 먼저 들고갔고,

친구는 종이를 먼저 들고갔다.

하지만 이 상황에서는 필기를 할 수 없다.

나는 종이가 없고, 친구는 연필이 없기 때문..

그래서 나는 친구에게 종이를 받기 위해 기다리고, 친구는 나에게 연필을 받기 위해 기다린다.

이 현상을 교착상태라고 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4416d208-0d1b-423e-8ad1-b718587c9520/Untitled.png)

서로 자원을 놓아 줄 생각은 없고, 하염없이 상대방의 자원을 요청하는 현상이다.

여기서 연필과 종이를 공유자원이라고 부르며, 이러한 공유자원이 속해있어 교착상태가 발생할 수 있는 영역을 임계영역 (Critical section)이라고 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d800747c-aebf-40f6-aaf2-2fb83d330e52/Untitled.png)

## 데드락 발생 조건

1. **상호 배제 (mutual exclusion)**
    1. 한 번에 하나의 프로세스/스레드만 크리티컬 섹션에서 실행하는 것을 의미
        
        → **쓰레드간 동기화를 실행해 크리티컬 섹션에 순서대로 진입하여 실행됨**
        
2. **점유 대기 (hold and wait)**
    1. 하나의 자원을 점유하고 있는 프로세스가 있고, 해당 프로세스가 다른 프로세스의 자원을 얻기 위해서는 대기하는 것
        
        → **리소스 하나를 들고 있고, 반환하지 않은 상태에서 다른 프로세스가 가진 리소스를 또 얻으려고 대기함.**
        
3. **비선점 (no preemption)**
    1. 특정 프로세스가 어떤 자원을 사용할 때, 해당 자원의 사용이 끝나기 전까지는 자원을 뺐을 수 없다.
        
        → **리소스 반환은 오직 그 리소스를 취득한 프로세스만 할 수 있다.**
        
4. **순환 대기 (circular wait)**
    1. 프로세스들이 서로 사용하고 있는 자원에 대해 순환적으로 대기하고 있는 형태
        
        **→ 프로세스들이 순환하면서 서로의 리소스를 기다림.**
        

데드락이 발생되지 않게 하려면???

상호 배제(**mutual exclusion)**를 활용하자.

# **어떻게 mutual exclusion을 보장할 수 있을까?**

## **락(lock)을 사용하자!**

mutual exclusion을 보장하기 위해 락이 등장하게 된다. 

critical section에서 한 번에 하나의 프로세스/스레드만 실행하기 위해서, critical section에 진입하기 전에 반드시 락을 취득하도록 했다. 

그래서 **락을 취득하는데 성공하면 critical section에서 실행하는 것이 가능하지만, 락을 취득하지 못하면 이미 그 락을 취득한 누군가가 그 락을 반환할 때까지 기다려야 한다.** 

- 아래 이미지는 이런 개념을 적용한 기본 뼈대라고 보면 되겠다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fee652e5-a460-41a3-ae57-08b61160e052/Untitled.png)
    
    아래 코드는 실제로 락을 어떻게 구현하는지를 보여주는 예시이다.
    
    **파란색은 락**
    
    **빨간색은 critical section**을 의미한다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/583386bd-e2e8-4d4b-9cd4-425920311af5/Untitled.png)
    
    우선 락은 글로벌하게 선언되어 어떤 스레드라도 접근 가능하다.
    
    ```java
    volatile int lock = 0; // 글로벌하게 선언됨
    ```
    
    초기값은 0
    
    이 락은 0 또는 1만 가질 수 있다.
    
    `citical()` 함수의 while 문을 보면 test_and_set을 호출해서 반환된 결과값이 1이면 조건문이 true 가 돼서 루프에 계속 머문다.
    
    반대로 결과값이 0이면 조건문이 false 가 돼서 루프를 탈출함.
    
    ```java
    volatile int lock = 0; // 글로벌하게 선언됨
    
    void critical() {
    	
    	while (test_and_set(&lock) == 1); // test_and_set() 결과가 1이면 반복, 0이면 탈출
    
    	... critical section
    
    	lock = 0;
    
    }
    ```
    
    `test_and_set()` 을 알아보자.
    
    ```java
    int TestAndSet(int* lockPtr) {
    	int oldLock = *lockPtr; // lock 값을 받아서 oldLock 변수에 저장
    	*lockPtr = 1; // 이후 lock 값을 1로 바꾼다.
    	return oldLock; // 이후 oldLock을 리턴
    }
    ```
    
    while 의 조건문으로 들어있는 test_and_set() 함수의 내부 구현이다.
    
    1. lock 값을 받아서 oldLock 변수에 저장한다.
    2. 이후 lock 값을 1로 바꾼다.
    3. 이후 oldLock을 리턴한다.
        
        이 oldLock에는 가장 처음 인자로 받은 락 값이 저장되어 있다.
        
    
    이 락의 값을 다시 0으로 바꿔주는 부분은 critical() 함수의 가장 아랫줄에 있다.
    
    **⁉️ 만약 2개의 스레드 t1, t2가 동시에 이 critical() 함수를 호출한다면??????**
    
    t1이 먼저 while의 조건문을 검사하게 된다면, 
    
    test_and_set은 0을 리턴하게 되고(이때, lock 값을 1로 바뀌게 되겠죠), 
    
    조건문은 false가 돼서 while 루프(loop)에 진입하지 않고 critical section에 들어가게 됨.
    
    ✅ 즉, t1은 락을 취득한 것
    
    이어서 t2가 while의 조건문을 검사하게 된다.
    
    이때는 이미 lock이 1로 바뀌었기 때문에, test_and_set은 1을 리턴하게 되고, 
    
    조건문이 true가 돼서 계속 while 루프 안에 머물게 된다.
    
    ✅ 즉, t2는 락을 취득하는데 실패한 것이다.
    
    이 t2가 while 루프를 탈출하기 위해서는 누군가가 lock 값을 다시 0으로 바꿔줘야 할 것이다.
    
    t1은 critical secion에서 자신이 할 일을 마친 후에 lock을 0으로 바꿔준다.
    
    그럼 이 순간 while 루프에서 무한 반복하며 조건문이 false가 되길 기다리던 t2는 드디어 test_and_set이 0을 리턴하면서 while 루프를 빠져나와 크리티컬 섹션으로 진입할 수 있게 된다.
    
    그런데 만약에 **t1과 t2가 test_and_set을 동시에 실행**하고, 
    
    그래서 둘 다 동시에 ***int oldLock = *lockPtr;*** 명령문을 실행하게 된다면, 
    
    둘 다 0을 가지고 올 수 있게 되고, 그렇다면 test_and_set도 둘 다 0을 리턴하니, 
    
    둘 다 while 조건문이 false가 돼서, 둘 다 critical section에 들어갈 수 있는 것 아닌가??
    
    test_and_set 함수에 비밀이 있다.
    
    ### ⭐ **CPU의 도움!!**
    
    **사실 TestAndSet은 CPU가 지원하는 atomic 명령어(operation)이다.**
    
    아토믹 명령어??
    
    - **실행 중간에 간섭받거나 중단되지 않는다**
    - **같은 메모리 영역에 대해 동시에 실행되지 않는다**
    
    그래서, 아까의 예를 다시 살펴보면, 
    
    두 개의 스레드가 test_and_set을 동시에 호출한다 할지라도, (심지어 멀티 코어 환경에서도) 이 **test_and_set은 순차적으로 실행**되며, 실행 중간에 멈추지 않는다.
    
    **반드시 실행되거나 전혀 실행되지 않거나** 이 두 경우뿐이죠.
    

# 상호배제(**mutual exclusion)보장을 위한 락 3가지**

# 1. **스핀락 (spinlock)**

****

스핀락은 while 루프를 탈출할 수 있을 때까지 반복해서 계속 시도를 하게 된다.

**이처럼 락을 취득하기 위해 계속해서 시도하는 방식을 스핀락이라고 한다.**

하지만 스핀락에는 단점이 있다.

**끊임없이 계속해서 while 루프의 조건문을 확인하기 위해 CPU 사이클을 낭비**한다는 점이 바로 그 단점이다.

다른 프로세스나 스레드가 더 유용하게 사용할 수 도 있었을 CPU 사이클이기 때문에 다른 프로세스나 스레드에게 피해를 주는 것이라고 볼 수 있다.

이를 개선하기 위한 락이 등장한다.

# 2. 뮤텍스락 (mutexlock)

스핀락이 쓰레드가 락을 취득할 수 있을 때까지 확인하면서 CPU 사이클을 낭비하는 락이였다면, 

**뮤텍스 락은 “락이 준비가 되면 나를 깨워달라”고 *요청하고 대기 상태*로 전환하는 락**이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c7c5bc56-508b-4dfd-98ba-ada9c7604108/Untitled.png)

뮤텍스 락을 취득하길 시도한다.

락을 취득하는데 성공한 스레드는 critical section에서 자기 할 일을 한 뒤에 critical section을 빠져나가면서 락을 반환한다.

만약 **이 스레드가 critical section에서 동작하는 동안 다른 스레드가 뮤텍스 락을 취득하려고 한다면, 취득에 실패하고 락을 취득할 때 자신을 깨워달라고 요청한 뒤 대기 상태로 전환**된다.

이런 형태로 뮤텍스는 critical secion의 mutual exclusion을 보장한다.

이처럼 **락을 가질 수 있을 때까지 휴식하며 기다리는, mutual exclusion을 보장하는 락을 뮤텍스**라고 한다.

## **뮤텍스가 스핀락보다 항상 좋은 걸까?**

멀티코어 환경이고, 크리티컬 섹션에서의 작업이 컨텍스트 스위칭에 걸리는 시간보다 더 빨리 긑난다면 스핀락이 뮤텍스보다 더 이점이 있다고 할 수 있겠쥬?

**멀티코어 + 크리티컬 섹션에서의 시간 < 컨텍스트 스위칭 시간 → 스핀락!**

왜??

**뮤텍스에서는 락을 취득하지 못한 쓰레드가 큐에 들어가게 되고 나중에 깨워줘야 하는데 이 과정에서 컨텍스트 스위칭이 발생**한다.

이 컨텍스트 스위칭이 cpu를 상당히 잡아먹는다…

만약 이렇게 컨텍스트 스위칭을 하는 것보다 크리티컬 섹션에서의 작업이 더 빨리 끝난다면, 스핀락 방식이 더 나은 것이다.

그럼 왜 멀티코어라는 조건이 붙는걸까???

싱글코어 환경에서는 스핀락이 전혀 이점이 없다.

싱글코어에서는 락을  취득하기 위해 스레드가 스핀락 방식으로 기다리고 있으면, 누군가는 락을 해제해야 하는데 그러려면 반드시 그 누군가로 컨텍스트 스위칭이 일어나야 하고,

그 누군가가 락을 해제한 뒤에는 기다리고 있는 스레드로 또다시 컨텍스트 스위칭이 일어나야 하기 때문…

하지만 멀티코어 환경을 생각해보자.

멀티코어 환경에서는 락을 취득한 스레드와 락을 기다리는 스레드가 서로 다른 코어에서 실행중이라면,

이 경우에는 컨텍스트 스위칭이 발생하지 않는다.

그래서 이런 조건일 때, 크리티컬 섹션에서의 작업 시간이 컨텍스트 스위칭에 걸리는 시간보다 짧다면 이때는 스핀락이 이점이 있다는 것.

# 3. 세마포어 (semaphore)

멀티프로그래밍 환경에서 다수의 프로세스나 쓰레드의 여러 개의 공유 자원에 대한 접근을 제한하는방법!!

## 세마포어와 뮤텍스와의 차이

***세마포어는 여러 쓰레드가 동시에 접근 가능***하다.

signal mechanism을 가진, 하나 이상의 프로세스/스레드가 critical section에 접근 가능하도록 하는 장치를 의미

세마포는 순서를 정해줄 때도 사용 가능하다.

뮤텍스와 거진 비슷하나, 세마포는 순서를 정해줄 때 자주 사용한다.

**그래서 상호 배제만 필요하다면 뮤텍스를,** 

**작업 간의 실행 순서 동기화가 필요하거나 두 개 이상의 프로세스/스레드가 critical section에서 동작해야 한다면 세마포 사용을 권장한다.**

**상호배제란?**

두 쓰레드가 있다고 가정할 때, 공유자원에 두 쓰레드가 동시에 접근할 수 없도록 통제하는 것을 의미한다.

# 동기화 3대장 락 간단 비교

### 1. 뮤텍스

mutual + exclusio의 합성어

상호 배제라는 의미이다.

예시를 들어보자.

1. 낡고 허름한 임계영역 식당이 있다고 가정.
    1. 배고픈 쓰레드 1이 식당에 들어가서 밥을 먹는다고 가정하자.
2. 이 식당은 자리가 1개 밖에 없기 때문에 쓰레드 1이 들어와 밥을 먹을 때는 식당 문을 걸어 잠근다.
    1. 여기서 식당문을 걸어 잠그는 것을 lock 방식이라고 함.
3. 쓰레드 1이 식사 도중, 쓰레드 2가 식당에 진입을 시도한다.
4. 하지만 식당은 쓰레드1이 식사를 하고있기 때문에 lock을 걸어 둔 상태
5. 쓰레드 2는 쓰레드 1이 식사를 다 끝내고 나올때까지 대기해야 한다.
    1. 이 때 대기하는 방식이 2개가 있다.
    2. **첫 번째 방법은 식당 뒷편 대기실에서 기다리고 있는다. 이 방식이 뮤텍스 방식!**
        
        → 쓰레드 1이 식사를 마친 후 식당을 빠져나가면 쓰레드 2는 대기실을 빠져나와 식당(임계영역)으로 들어간다.
        

<aside>
💡 **뮤텍스는 이렇게 임계영역에서 작업하고 있는 쓰레드가 있다면, 
다른 쓰레드는 대기줄에서 대기하도록 시킨다. (sleeping-wating - blocking-lock)**

</aside>

### 2. 스핀락

1. 동일한 조건 하에서 쓰레드 2는 식당에 들어가지 못하고 쓰레드1이 식사가 끝날 때 까지 기다리게 된다.
    1. 이 때 뮤텍스와 다르게 대기실에 들어가지 않고 **식당 문 앞에서 계속 기다리면서 쓰레드 1이 식사가 끝났는지 지속적으로 식당에 물어보게 된다. → 스핀락 방식!!**
2. 이렇게 문앞에서 기다리면서 지속적으로 식당에 물어보는 방식을 **busy-waiting** 이라고 한다.
    1. 이 비지 웨이팅은 문앞에서 기다리는 쓰레드가 계속해서 식당에 자리가 났는지를 물어보기 때문에 식당 종업원은 쉬지를 못한다.
    2. 그래서 사장님이 혼자 운영하는 식당이라면 설거지, 요리, 뒷정리, 손님응대 등 모든 작업을 혼자 해야하기 때문에 비효율적이다.

<aside>
💡 **이** **busy-waiting 때문에 CPU가 하나가 있는 환경에서는 세마포어까지 관리해야 하기 때문에 비효율적이다.**

</aside>

### 3. 세마포어

1. 이번에는 식당이 리모델링을 해서 여러 쓰레드가 진입할 수 있다고 가정하자.
    1. 세마포어는 임계 영역에 여러 쓰레드가 진입 가능
2. 식당에 여러 쓰레드가 진입하고, 진입하는 순간 P를 외치고, 식당에서 나오면서 V를 외친다.
3. 식당에 자리가 나면 쓰레드는 식당에 진입하고, 자리가 나지 않는다면 대기실에서 대기하고 있다가 자리가 날 때 들어가거나(뮤텍스 방식), 문 앞에서 계속해서 자리가 났는지 물어보고 자리가 나면 들어가도록(스핀락) 한다.

<aside>
💡 **세마포어는 임계영역 앞에서 계속 기다리면서 쓰레드 1이 작업을 끝냈는지 지속적으로
확인한다. 그래서 CPU가 하나가 있는 환경에서는 이 세마포어까지 관리해야 하기 때문에 비효율 적이다.**

</aside>

## 뮤텍스와 비교, 언제 스핀락을 사용하면 좋을까?

1. 대기실까지 이동하는 시간(1분 가정)보다 식당 진입 시간(50초 가정)이 더 짧은 경우
    
    → **컨텍스트 스위칭이 더 짧을 경우**
    
2. 사장님 혼자 운영하는 것이 아닌, 직원이 여러명 있는 식당인 경우
    
    → **멀티 코어 프로세스 인 경우**
    

# 정리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92e279ba-fcb9-49a9-ab9d-db40464a05a3/Untitled.png)

# ref

---

[https://blog.naver.com/myca11/222626631093](https://blog.naver.com/myca11/222626631093)

[https://velog.io/@moonheekim0118/운영체제-뮤텍스와-세마포어](https://velog.io/@moonheekim0118/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4)
