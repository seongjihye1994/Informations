# *메시지 큐(message queue)*

## 메세지 큐란?

**프로세스끼리 데이터를 교환**할때 사용하는 통신 방법

즉, 통신을 위한 큐 자료구조

메시지 큐는 메시지를 임시로 저장하는 간단한 버퍼처럼 생각하면 된다.

![https://user-images.githubusercontent.com/50273712/133918874-2664898b-a080-4df6-bd21-fad7a204029d.png](https://user-images.githubusercontent.com/50273712/133918874-2664898b-a080-4df6-bd21-fad7a204029d.png)

대용량의 데이터를 처리하기 위해 분산 처리할때 쓰인다. 

대부분은 일단 메시지 큐에 메시지를 넣어두고 필요한 쪽에서 알아서 받아서 처리해서 사용한다.

### 메세지 큐는 일대일 통신

👤 메시지 **전송** 및 메시지를 **메시지 큐에 추가** ➡️ ***생산자(Producer)***

👤 메시지를 **검색**하고 이를 **사용** ➡️ ***소비자(Consumer)***

## **메시지 큐의 장점**

- **비동기 (Asynchronous)**
    - Queue에 넣기 때문에 나중에 처리할 수 있다.
        - 메시지 큐는 소비자(Consumer)가 실제로 메시지를 어느 시점에 가져가서 처리하는 지는 보장하지 않는다.
        - 언젠가는 큐에 넣어둔 메시지가 소비되어 처리될 것이라고 믿는 것이다.
- **비동조 (Decoupling)**
    - Appliction 과 분리할 수 있다. (각 서비스의 연결을 느슨하게 함)
- **탄력성 (Resilience)**
    - 일부가 실패 시 전체에 영향을 받지 않는다.
- **과잉 (Redundancy)**
    - 실패할 경우 재실행 가능하다.
- **보증 (Guarantees)**
    - 작업이 처리된걸 확인할 수 있다.
- **확장성 (Scalable)**
    - 다수의 프로세스들이 큐에 메시지를 보낼 수 있다.

## 메세지 큐 사용 용도

### 1. **이메일 전송**

어떤 웹 사이트의 비밀번호를 잊어버려서 이메일을 통해 임시 비밀번호를 받거나, 새로운 회원가입을 위한 인증 코드를 받아본 경험이 있을 것이다. 

우리는 이러한 상황들에서 이메일이 즉각적으로 수신되기를 기대하지는 않는다. 

아무리 성격이 급한 사람이라도 몇 분 안에 오겠거니 생각할 것이다. 

**어느 정도의 응답 지연이 허용되며, 어플리케이션의 핵심 기능은 아닌 경우**이므로 메시지 큐는 이런 경우 도움이 될 수 있다.

- 비밀번호 재설정을 위해 이메일을 발급하는 서비스, 회원가입을 위해 이메일을 발급하는 서비스 등은 메시지(이메일)를 큐에 넣을 수 있다.
- 이메일 전송 전용 서비스는 **이메일이 어느 서비스로부터 생산되었는지와는 관계 없이, 메시지 큐의 메시지를 하나씩 소비**하고, 그저 **이메일이 전송되어야 할 곳으로 이메일을 전송**한다.
- 이와 같은 접근 방식은 메시지 큐에 들어오는 메시지 수가 너무 많아지는 경우 이메일 전송 전용 서비스 인스턴스를 더 둠으로써 확장할 수 있으므로 확장성이 뛰어나다.

### 2. 블로그 포스팅

모든 블로그 사용자가 웹에 최적화되어 있거나, 용량이 작은 이미지만 업로드하진 않을 것이다. 

블로그 사용자가 게시글에 업로드한 이미지의 용량이 매우 큰 경우를 생각해보자. 

블로그 서비스의 응답 시간을 저해하지 않으면서 사용자들에게 유연성을 제공하는 방법으로, **사용자가 업로드한 모든 이미지를 게시 과정에서 즉각 처리하는 것이 아닌, 사후처리하며 최적화**하는 방법이 있다. 

사용자 경험에 약간의 영향을 미칠 수는 있지만, **최적화는 응용 프로그램에서 가장 중요한 것은 아니며 작업을 즉시 수행할 필요도 없다.** 

메시지 큐는 이러한 상황에서도 사용될 수 있다.

1. 사용자가 고용량의 이미지가 포함된 블로그 포스팅을 한다.
2. 이미지는 저장소에 전송된다.
3. 업로드된 이미지에 대한 정보(ex. 메타파일)가 포함된 메시지를 이미지 최적화 서비스의 메시지 큐에 담는다.
4. 이미지 최적화 서비스는 저장소에서 이미지를 가져와 최적화하고, 2번에서 저장해놨던 이미지를 대체한다.

## **RabbitMQ vs Kafka**

메시지 브로커와 이벤트 스트리밍 플랫폼 모두 이벤트를 수신하고, 이것을 소비자에게 전달하는 데에 목적을 두고 있지만 작동 방식에 큰 차이가 있다.

### **RabbitMQ는 전통적인 메시지 브로커 방식**

- RabbitMQ는 "생산자와 소비자간의 보장되는 메시지 전달"에 초점을 맞춰 **브로커 중심**적인 특징
    - Event Producer가 메세지를 생성하면, 메세지 브로커인 RabbitMQ내에서 이 메세지를 어떤 큐에 발송할지 결정하는 exchange를 하게 되고, 이렇게 큐에 들어간 메세지는 Event Consumer가 가져가게 된다.
    - 따라서 컨슈머가 메시지를 가져가면 큐에는 더 이상 남지 않고 사라지게 된다.
    - 이 때 메시지 "큐"의 특성에 따라 "선입선출"이 적용되어 메시지는 순서대로 컨슈머에게 제공되고, 컨슈머는 미리 정해둔 한계점까지 지속적으로 메시지를 큐에서 읽어들인다.
- 전통적인 메시지 브로커의 형태는 **소비자와 메시지 브로커의 결합력이 높아**지게 되어 후에 앱의 트래픽이 증가하여도 수평적으로 확장하는 데에 어려움이 있다.

### **Kafka는 최신 기술로 사용되고 있는 이벤트 브로커 플랫폼 방식**

- 전통적인 메시지 브로커 방식의 단점을 보완하기 위해 만들어진 이벤트 스트리밍 방식
- 이벤트 브로커는 기본적으로 메시지 브로커의 큐 기능들을 가지고 있다.
- 그래서 메시지 브로커는 이벤트 브로커의 역할을 할 수 있지만 메시지 브로커는 이벤트 브로커의 역할을 할 수 없다.
    - 이벤트 스트리밍 플랫폼은 메시지 브로커와 다르게 **topic이라는 것이 event streamer에 저장**됨.
    - Event producer가 이벤트를 생성하면, 토픽이라고 불리는 이벤트의 레코드 로그를 streamer에 순서대로 기록하게 된다.
    - 그 후 해당 토픽을 구독(subscribe)한 컨슈머에게 전달하게 된다.
    - 또한 이 토픽을 컨슈머가 가져간 후에도 이벤트 스트림에서 계속 토픽을 유지하기 때문에 오류 수정이 필요하거나 앱을 리빌드 하는 등의 상황에서 이벤트를 다시 재생시킬 수 있다.

### 정리

RabbitMQ의 경우 kafka에 비해 좀 더 쉽지만 컨슈머와 메시지 브로커간의 결합도가 높기 때문에

트래픽이 작으면서 비즈니스가 후에 확장되지 않을 확률이 높다면 RabbitMQ를 사용하는 것이 좋다.

하지만 대규모 트래픽이 예상되고, 추후 확장이 예상된다면 kafka를 선택하는 것이 좀 더 바람직하다.
